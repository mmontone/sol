<?xml version="1.0"?><st-source><!-- Name: solBundleName: SolBundleStructure: a Store.BundleForParcelParcel: #('Sol')ParcelName: solDate: 7:32:27 pm September 6, 2005 --><time-stamp>From VisualWorks® NonCommercial, Release 7 of March 21, 2003 on September 6, 2005 at 7:32:27 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Sol</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Sol</category><attributes><package>Sol-Model</package></attributes></name-space><comment><name-space-id>Sol</name-space-id><body>Espacio de nombres para aplicaciones Solitario</body></comment><name-space><name>AST</name><environment>Sol</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></name-space><class><name>HandlerB</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Tests</category><attributes><package>Sol-Tests</package></attributes></class><class><name>GeneralASTGrammarBuilder</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GrammarBuilders</category><attributes><package>Sol-Parser</package></attributes></class><comment><class-id>Sol.GeneralASTGrammarBuilder</class-id><body>GeneralGrammarBuilder creates the AST based on ASTNodes.La idea es tener los elementos en objetos ASTNode generales. Lo que hacen es responder a mensajes acerca de sus propiedades (por ejemplo: node name, node decks, etc). Esto es solo interceptar el mensaje doesNotUnderstand y devolver la propiedad guardada en un diccionario indexado por el nombre de la propiedad. Ademas responden al accept de un visitor con visit&lt;name&gt;. En este caso el print no se implementaria en cada nodo, sino en un visitor especialmente diseñado para eso.Nos evitamos mantener la estructura del AST</body></comment><class><name>ASTGrammarBuilder</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GrammarBuilders</category><attributes><package>Sol-Parser</package></attributes></class><comment><class-id>Sol.ASTGrammarBuilder</class-id><body>StandardGrammarBuilder constructs the AST based on the classes defined in Sol-Parser</body></comment><class><name>SolConfig</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Config</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.SolConfig</class-id><body>SolConfig provides access to the different ConfigProxy objects of the configurated application</body></comment><class><name>CardSuitSubExpression</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Gold</name><environment>Sol.AST</environment><super>Sol.AST.CardSuitSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>InitAll</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Action</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Move</name><environment>Sol.AST</environment><super>Sol.AST.Action</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>RemoveCards</name><environment>Sol.AST</environment><super>Sol.AST.Action</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>WastePilesSpec</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>ASTNode</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GrammarBuilders</category><attributes><package>Sol-Parser</package></attributes></class><comment><class-id>Sol.ASTNode</class-id><body>ASTNode is a general AST nodeInstance Variables:	properties	&lt;Object&gt;	description of properties</body></comment><class><name>TracerGrammarBuilder</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Parser</category><attributes><package>Sol-Parser</package></attributes></class><comment><class-id>Sol.TracerGrammarBuilder</class-id><body>TracerGrammarBuilder se usa para debuggear una gramatica. No construye los elementos, sino que informa en el transcript los elementos que le van requiriendo crear.</body></comment><class><name>Init</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CardsStack</name><environment>Sol</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cards </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol FrameWork</category><attributes><package>Sol-Model</package></attributes></class><comment><class-id>Sol.CardsStack</class-id><body>CardsStack es abstracta. Superclase para una pila de cartasInstance Variables:	cards	&lt;(OrderedCollection of: Object)&gt;	description of cards</body></comment><class><name>ConfigBuilder</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Config</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.ConfigBuilder</class-id><body>ConfigBuilder provee una interface para la creacion de una configuracion.Objetivos: el cliente no debe saber como esta conformada una configuracion.Un config proxy especial podria ser pasado como config builder. Este objeto sabria como construirse (se iria construyendo a medida que el cliente va poblandolo de datos). Ademas la configuracion podria ser accedida ya que es un config proxy.Hay un solo builder ya que la estructura de la configuracion esta fija. Deberia esto ser asi realmente?</body></comment><class><name>RemoveFromTalonHeader</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CanvasController</name><environment>Sol</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.CanvasController</class-id><body>Controlador de la zona de dibujo (canvas)</body></comment><class><name>Pile_Variable</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pile var </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Rule</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>LoseRule</name><environment>Sol.AST</environment><super>Sol.AST.Rule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CommonRule</name><environment>Sol.AST</environment><super>Sol.AST.Rule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>DraggableCardFocusTracker</name><environment>Sol</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>initialized </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.DraggableCardFocusTracker</class-id><body>DraggableCardFocusTracker hace de controller de toda la aplicacion mientras se esta desplazando una carta. Todos los eventos que suceden mientras se esta desplazando una carta son interceptados por este objeto.</body></comment><class><name>NoTalon</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Decks</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>ASTNodeTest</name><environment>Sol</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Tests</category><attributes><package>Sol-Tests</package></attributes></class><class><name>ChainTest</name><environment>Sol</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>chain </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Tests</category><attributes><package>Sol-Tests</package></attributes></class><class><name>VisualComponent</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>VisualComponent</class-id><body>Ignorar. Probando...</body></comment><class><name>ConfigValidator</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.ConfigValidator</class-id><body>ConfigValidator validates a configuration against a ConfigStructure.</body></comment><class><name>UndoAction</name><environment>Sol.AST</environment><super>Sol.AST.Action</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>XMLConfigReaderTest</name><environment>Sol</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>doc testFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Tests</category><attributes><package>Sol-Tests</package></attributes></class><class><name>Rough</name><environment>Sol.AST</environment><super>Sol.AST.CardSuitSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>TupleObjectTest</name><environment>Sol</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Tests</category><attributes><package>Sol-Tests</package></attributes></class><class><name>PokerDeck</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>DeckClassConfigProxy</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name suits cardsPerSuit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.DeckClassConfigProxy</class-id><body>La definicion de una clase de mazo. Se instancia por DeckClassesConfigProxy para el acceso a la configuracionInstance Variables:	cardsPerSuit	&lt;OrderedCollection&gt;	 Collection of symbols representing the names of the cards for each suit	name	&lt;String&gt;	The deck class name	suits	&lt;OrderedCollection&gt;	 Collection of symbols  representing the name of the suits</body></comment><class><name>CardTypeSubExpression</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PreviousCardType</name><environment>Sol.AST</environment><super>Sol.AST.CardTypeSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>SolFactory</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Model</category><attributes><package>Sol-Model</package></attributes></class><comment><class-id>Sol.SolFactory</class-id><body>SolFactory crea los objetos requeridos por la aplicacion segun la configuracion</body></comment><class><name>PileController</name><environment>Sol</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.PileController</class-id><body>Controlador de una pila</body></comment><class><name>Pile</name><environment>Sol</environment><super>Sol.CardsStack</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-Model</package></attributes></class><comment><class-id>Sol.Pile</class-id><body>Una pila de cartas</body></comment><class><name>ConfigProxy</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>config </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.ConfigProxy</class-id><body>ConfigProxy provee una interfaz para acceder a los datos de una configuracion. Separa el acceso a la configuracion de como esta conformada una configuracionInstance Variables:	config	&lt;(Collection of: Object) | RBProgramNode&gt;	description of config</body></comment><class><name>DeckStylesConfigProxy</name><environment>Sol</environment><super>Sol.ConfigProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Config</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.DeckStylesConfigProxy</class-id><body>DeckStylesConfigProxy actua como interface para leer una configuracion especifica de estilos de mazos. Es probable que la informacion pueda obtenerse directamente analizando la estructura de los directorios y archivos que conforman el estilo, sin embargo esta estructura intermedia es util por si la informacion se quiere obtener de otra forma en el futuro (archivo XML, por ejemplo). Estamos haciendo una especie de aspect oriented programming (separando la lectura de la configuracion de su acceso)</body></comment><class><name>DeckStyleConfigProxy</name><environment>Smalltalk</environment><super>Sol.ConfigProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Config</category><attributes><package>Sol-Config</package></attributes></class><class><name>Configuration</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decks wastePiles talons foundations playingPiles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CardsDistributor</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>deck mode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol FrameWork</category><attributes><package>Sol-Model</package></attributes></class><comment><class-id>Sol.CardsDistributor</class-id><body>CardsDistributor se encarta de repartir un mazo de cartas dado.Instance Variables:	deck	&lt;CardsStack&gt;	description of deck	mode	&lt;Object&gt;	description of mode</body></comment><class><name>ImageView</name><environment>Sol</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol FrameWork</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.ImageView</class-id><body>La vista simple de una imagen</body></comment><class><name>CardView</name><environment>Sol</environment><super>Sol.ImageView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.CardView</class-id><body>La vista de una carta</body></comment><class><name>TalonView</name><environment>Sol</environment><super>Sol.ImageView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>backImage emptyImage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.TalonView</class-id><body>Vista del talon</body></comment><class><name>Talon</name><environment>Sol</environment><super>Sol.CardsStack</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cardsManager takeAmount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol FrameWork</category><attributes><package>Sol-Model</package></attributes></class><comment><class-id>Sol.Talon</class-id><body>El talonInstance Variables:	cardsManager	&lt;SolApplication&gt;	description of cardsManager	takeAmount	&lt;Object&gt;	description of takeAmount</body></comment><class><name>DeckClassesConfigProxyTest</name><environment>Sol</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testFile proxy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Tests</category><attributes><package>Sol-Tests</package></attributes></class><class><name>DeckVisualStyle</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.DeckVisualStyle</class-id><body>DeckVisualStyle posee información de los archivos con las imágenes correspondientes al mazo actual. Es configurable. Un mazo limita el espectro de estilos visuales que posee.Por ejemplo: no es lo mismo un mazo de cartas españolas que de poker, y cada uno de ellos poseen diferentes representaciones visuales, las cuales están delimitadas por el tipo de mazo.</body></comment><class><name>PockerDeckVisualStyle</name><environment>Sol</environment><super>Sol.DeckVisualStyle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instVarName1 instVarName2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.PockerDeckVisualStyle</class-id><body>Se diferencian de las españolas en la cantidad de cartas</body></comment><class><name>CardController</name><environment>Sol</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-UI</package></attributes></class><class><name>DescriptionLine</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conditions actions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>SolApplication</name><environment>Sol</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>solName canvas talon piles deck decks repository distributor deckVisualStyle conf factory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>Sol-Model</package></attributes></class><comment><class-id>Sol.SolApplication</class-id><body>La aplicación. Para definir un nuevo solitario subclasificar SolApplication. Actua como capa intermedia entre la vista y el modelo. Contruye una vista a partir de información del modelo. Nota para la parte visual: los componentes visuales no asumen casi nada acerca de su modelo. Por ejemplo, en el caso de TalonView, el model puede ser tanto un talon como la aplicacion principal. Por lo tanto, usar un Adaptor. Por ejemplo, en el caso anterior, si queremos manejar el talon desde la aplicacion podemos configurar un adaptor de la siguiente manera: 'empty' -&gt; 'talonEmpty'. De esta forma, cada vez que la vista pregunta por si el modelo esta vacío, el mensaje talonEmpty le llegará a la aplicación principal, que estaría actuando como Mediator.Subclasses must implement the following messages:	events		takeCardsFromTalon:	interface opening		playingPilesViewClassInstance Variables:	canvas	&lt;CompositePart&gt;	description of canvas	deck	&lt;CardsStack&gt;	description of deck	distributor	&lt;CardsDistributor&gt;	description of distributor	piles	&lt;ByteFieldDescriptor | CCompoundType | (Collection of: Object) | MC_FileBTree | MessageTally | PostgreSQLQueryResultList | RBProgramNode | Stream&gt;	description of piles	repository	&lt;CardsStack&gt;	description of repository	solName	&lt;String&gt;	description of solName	talon	&lt;CardsStack&gt;	description of talon</body></comment><class><name>WinRule</name><environment>Sol.AST</environment><super>Sol.AST.Rule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Condition</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>SimpleCondition</name><environment>Sol.AST</environment><super>Sol.AST.Condition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>False</name><environment>Sol.AST</environment><super>Sol.AST.SimpleCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>EmptyPile</name><environment>Sol.AST</environment><super>Sol.AST.SimpleCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>True</name><environment>Sol.AST</environment><super>Sol.AST.SimpleCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>ForEach</name><environment>Sol.AST</environment><super>Sol.AST.Condition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pile variable conditions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>OrForEach</name><environment>Sol.AST</environment><super>Sol.AST.ForEach</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>AndForEach</name><environment>Sol.AST</environment><super>Sol.AST.ForEach</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PileView</name><environment>Sol</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bottomImage layout separation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.PileView</class-id><body>Vista de una pila</body></comment><class><name>Heart</name><environment>Sol.AST</environment><super>Sol.AST.CardSuitSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Canvas</name><environment>Sol</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.Canvas</class-id><body>La zona de dibujo</body></comment><class><name>CardsTracker</name><environment>Sol</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visualObject background canAddCardsSelector addCardsSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.CardsTracker</class-id><body>Desplaza una carta por la pantalla</body></comment><class><name>NextCardType</name><environment>Sol.AST</environment><super>Sol.AST.CardTypeSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CardSuit</name><environment>Sol.AST</environment><super>Sol.AST.CardSuitSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>card </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>TalonController</name><environment>Sol</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.TalonController</class-id><body>Controlador del talon</body></comment><class><name>EventGrammarBuilder</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Parser</category><attributes><package>Sol-Parser</package></attributes></class><comment><class-id>Sol.EventGrammarBuilder</class-id><body>EventGrammarBuilder podria ser un objeto configurable tal que no construya un arbol, sino que invoque determinados eventos cada vez que una regla hace matching (ver o SAX).Si el parsing se hace top-down podria ser una buena opcion para compilar la aplicacion sin tener que mantener la estructura del arbol</body></comment><class><name>TalonSpec</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count turn circular repository </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>IntegerSubExpression</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CardsCountInPilesType</name><environment>Sol.AST</environment><super>Sol.AST.IntegerSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pileType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>ArithmeticalOperation</name><environment>Sol.AST</environment><super>Sol.AST.IntegerSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operand1 operand2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Mult</name><environment>Sol.AST</environment><super>Sol.AST.ArithmeticalOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Div</name><environment>Sol.AST</environment><super>Sol.AST.ArithmeticalOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Minus</name><environment>Sol.AST</environment><super>Sol.AST.ArithmeticalOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>BinaryCondition</name><environment>Sol.AST</environment><super>Sol.AST.Condition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cond1 cond2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Variable</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>var </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>ConfigStructure</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.ConfigStructure</class-id><body>ConfigStructure define estructura de una configuracion</body></comment><class><name>SpanishDeckVisualStyle</name><environment>Sol</environment><super>Sol.DeckVisualStyle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.SpanishDeckVisualStyle</class-id><body>Se diferencian de las de pocker en la cantidad de cartas</body></comment><class><name>Cup</name><environment>Sol.AST</environment><super>Sol.AST.CardSuitSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Chain</name><environment>Sol</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars>targets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Util</package></attributes></class><comment><class-id>Sol.Chain</class-id><body>Chain passes a request along a chain of target objectsInstance Variables:	targets	&lt;Object&gt;	description of targets</body></comment><class><name>TurnCards</name><environment>Sol.AST</environment><super>Sol.AST.Action</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>DeckClassesConfigStructure</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.DeckClassesConfigStructure</class-id><body>DeckClassesConfigStructure define estructura de una configuracion</body></comment><class><name>PilesType</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Talons</name><environment>Sol.AST</environment><super>Sol.AST.PilesType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>talons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Foundations</name><environment>Sol.AST</environment><super>Sol.AST.PilesType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CardsCountInPile</name><environment>Sol.AST</environment><super>Sol.AST.IntegerSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>InitRest</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>HandlerA</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Tests</category><attributes><package>Sol-Tests</package></attributes></class><class><name>ConfigStructureReader</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.ConfigStructureReader</class-id><body>ConfigStructureReader crea un objeto ConfigStructure a partir de un archivo u objeto de Smalltalk</body></comment><class><name>TupleObject</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Util</package></attributes></class><comment><class-id>Sol.TupleObject</class-id><body>Este objeto es utilizado para agrupar propiedades.Ejemplo:to := TupleObject new addProperty: #name put: 'Mariano'.Y luego:to name</body></comment><class><name>And</name><environment>Sol.AST</environment><super>Sol.AST.BinaryCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>GameSpecification</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name configuration init rules </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PileCardController</name><environment>Sol</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.PileCardController</class-id><body>El controlador que debe utilizar una carta en caso que se encuentre dentro de una pila</body></comment><class><name>Pile</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Foundation</name><environment>Sol.AST</environment><super>Sol.AST.Pile</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PlayingPile</name><environment>Sol.AST</environment><super>Sol.AST.Pile</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>WastePile</name><environment>Sol.AST</environment><super>Sol.AST.Pile</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Talon</name><environment>Sol.AST</environment><super>Sol.AST.Pile</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PrettyPrintVisitor</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Parser</category><attributes><package>Sol-Parser</package></attributes></class><comment><class-id>PrettyPrintVisitor</class-id><body>PrettyPrintVisitor imprime una representacion textual de un AST cualquiera (sea general o especifico)</body></comment><class><name>AllDecks</name><environment>Sol.AST</environment><super>Sol.AST.PilesType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>NoWastePiles</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>UnaryCondition</name><environment>Sol.AST</environment><super>Sol.AST.Condition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Not</name><environment>Sol.AST</environment><super>Sol.AST.UnaryCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>ListInitValues</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Card</name><environment>Sol</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name suit value side deck </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-Model</package></attributes></class><comment><class-id>Sol.Card</class-id><body>Una cartaInstance Variables:	deck	&lt;Object&gt;	description of deck	number	&lt;Object&gt;	description of number	side	&lt;Object&gt;	description of side	suit	&lt;Object&gt;	description of suit</body></comment><class><name>Golf</name><environment>Sol</environment><super>Sol.SolApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Apps</category><attributes><package>Sol-Golf</package></attributes></class><comment><class-id>Sol.Golf</class-id><body>El solitario denominado Golf</body></comment><class><name>MoveHeader</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>WastePiles</name><environment>Sol.AST</environment><super>Sol.AST.PilesType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PileLayout</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.PileLayout</class-id><body>Indica como se distribuyen las cartas en la vista de una pila. Cada vista de una pila posee uno, y puede cambiarse en tiempo de ejecución.</body></comment><class><name>HorizontalPileLayout</name><environment>Sol</environment><super>Sol.PileLayout</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.HorizontalPileLayout</class-id><body>Distribucion de cartas horizontal</body></comment><class><name>FlatPileLayout</name><environment>Sol</environment><super>Sol.PileLayout</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.FlatPileLayout</class-id><body>Las cartas se ubican una arriba de la otra</body></comment><class><name>VerticalPileLayout</name><environment>Sol</environment><super>Sol.PileLayout</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol UI</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.VerticalPileLayout</class-id><body>Las cartas se ubican de forma vertical</body></comment><class><name>GolfRepository</name><environment>Sol</environment><super>Sol.Pile</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Apps</category><attributes><package>Sol-Golf</package></attributes></class><comment><class-id>Sol.GolfRepository</class-id><body>El repositorio de un Golf</body></comment><class><name>ConfigReader</name><environment>Sol</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.ConfigReader</class-id><body>Creates a configuration from some input (XML, Smalltalk class, etc). The main parser should be a ConfigReader.Lo adecuado seria utilizar un objeto ConfigBuilder como colaborador e ir poblandolo para crear la nueva configuracion</body></comment><class><name>XMLConfigReader</name><environment>Sol</environment><super>Sol.ConfigReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename builder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.XMLConfigReader</class-id><body>Creates a Config object from an XML configuration file. Its general. (No presupone una estructura determinada en el archivo XML)</body></comment><class><name>DirectoryDeckStylesReader</name><environment>Sol</environment><super>Sol.ConfigReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Config</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.DirectoryDeckStylesReader</class-id><body>DirectoryDeckStylesReader generates a configuration from the directory structure for the deck styles</body></comment><class><name>SmallConfigReader</name><environment>Sol</environment><super>Sol.ConfigReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.SmallConfigReader</class-id><body>SmallConfigReader creates a Config object from a Smalltalk class information. Its configurable</body></comment><class><name>Rules</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rules </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Or</name><environment>Sol.AST</environment><super>Sol.AST.BinaryCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>GolfPile</name><environment>Sol</environment><super>Sol.Pile</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Apps</category><attributes><package>Sol-Golf</package></attributes></class><comment><class-id>Sol.GolfPile</class-id><body>La Pila de un Golf</body></comment><class><name>CardType</name><environment>Sol.AST</environment><super>Sol.AST.CardTypeSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>card </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Joker</name><environment>Sol.AST</environment><super>Sol.AST.CardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Queen</name><environment>Sol.AST</environment><super>Sol.AST.CardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>As</name><environment>Sol.AST</environment><super>Sol.AST.CardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>King</name><environment>Sol.AST</environment><super>Sol.AST.CardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Ten</name><environment>Sol.AST</environment><super>Sol.AST.CardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Number</name><environment>Sol.AST</environment><super>Sol.AST.CardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PlayingPilesSpec</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>DeckClassesConfigProxy</name><environment>Sol</environment><super>Sol.ConfigProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol-Util</category><attributes><package>Sol-Config</package></attributes></class><comment><class-id>Sol.DeckClassesConfigProxy</class-id><body>Actua como interface para leer una configuracion especifica de clases de mazos. Sabe como recorrer la configuracion con el fin de cumplir con la interface que esta especificando. Quizás podría hacerse general con reflectionEjemplo: (DeckClassesConfigProxy on: (XMLConfigReader read: 'deck_classes.xml')) deckClassesInstance Variables:	config	&lt;Config&gt;	El objeto con la configuracion</body></comment><class><name>SpanishDeck</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Club</name><environment>Sol.AST</environment><super>Sol.AST.CardSuitSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>ComparisonExpression</name><environment>Sol.AST</environment><super>Sol.AST.SimpleCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elem1 elem2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Comparison</name><environment>Sol.AST</environment><super>Sol.AST.ComparisonExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>ComparisonNot</name><environment>Sol.AST</environment><super>Sol.AST.ComparisonExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>GreaterE</name><environment>Sol.AST</environment><super>Sol.AST.ComparisonExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Lower</name><environment>Sol.AST</environment><super>Sol.AST.ComparisonExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>LowerE</name><environment>Sol.AST</environment><super>Sol.AST.ComparisonExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Greater</name><environment>Sol.AST</environment><super>Sol.AST.ComparisonExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Implies</name><environment>Sol.AST</environment><super>Sol.AST.BinaryCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>FoundationSpec</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>InitCount</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>TalonsInitCount</name><environment>Sol.AST</environment><super>Sol.AST.InitCount</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>WastePileInitCount</name><environment>Sol.AST</environment><super>Sol.AST.InitCount</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PlayingPileInitCount</name><environment>Sol.AST</environment><super>Sol.AST.InitCount</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>FoundationsInitCount</name><environment>Sol.AST</environment><super>Sol.AST.InitCount</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Spade</name><environment>Sol.AST</environment><super>Sol.AST.CardSuitSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Diamond</name><environment>Sol.AST</environment><super>Sol.AST.CardSuitSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CardColorSubExpression</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CardColorExpression</name><environment>Sol.AST</environment><super>Sol.AST.CardColorSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>card </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Black</name><environment>Sol.AST</environment><super>Sol.AST.CardColorSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Red</name><environment>Sol.AST</environment><super>Sol.AST.CardColorSubExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>CardExpression</name><environment>Sol.AST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>PreviousCard</name><environment>Sol.AST</environment><super>Sol.AST.CardExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>card </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>NextCard</name><environment>Sol.AST</environment><super>Sol.AST.CardExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>card </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>TopPile</name><environment>Sol.AST</environment><super>Sol.AST.CardExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>StandardPockerDeckVisualStyle</name><environment>Sol</environment><super>Sol.PockerDeckVisualStyle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-UI</package></attributes></class><comment><class-id>Sol.StandardPockerDeckVisualStyle</class-id><body>Estilo standard para un mazo de pocker</body></comment><class><name>Plus</name><environment>Sol.AST</environment><super>Sol.AST.ArithmeticalOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol Grammar</category><attributes><package>Sol-AST</package></attributes></class><class><name>Deck</name><environment>Sol</environment><super>Sol.CardsStack</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mixTimes type cardsPerSuit suits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sol</category><attributes><package>Sol-Model</package></attributes></class><comment><class-id>Sol.Deck</class-id><body>Un mazo de cartas</body></comment><shared-variable><name>GrammarBuilder</name><environment>Sol.SolApplication</environment><private>false</private><constant>false</constant><category>parser</category><initializer>TracerGrammarBuilder new</initializer><attributes><package>Sol-Model</package></attributes></shared-variable><methods><class-id>Sol.HandlerB</class-id> <category>handle request</category><body package="Sol-Tests">handleB	^'B'</body></methods><methods><class-id>Sol.ASTGrammarBuilder</class-id> <category>building</category><body package="Sol-Parser">buildConfiguration: decks wastePiles: wastePiles talons: talons foundations: foundations playingPiles: playingPiles	^Sol.Grammar.Configuration new: decks wastePiles: wastePiles talons: talons foundations: foundations playingPiles: playingPiles</body><body package="Sol-Parser">buildDeck: name type:t	"Tiene en cuenta que puede haber varios mazos y hacer diferentes cosas con cada mazo, por lo tanto hay que nombrarlos"	^Sol.Grammar.Decks new:name value type:t</body><body package="Sol-Parser">buildDecks: cant type:t	^Sol.Grammar.Decks new:cant value type:t</body><body package="Sol-Parser">buildFoundation: cant	^Sol.Grammar.FoundationSpec new: cant value</body><body package="Sol-Parser">buildGameSpecification: n init: ini configuration:conf rules: rules 	^Sol.Grammar.GameSpecification new: n init: ini configuration:conf rules: rules</body><body package="Sol-Parser">buildInitConf: initConf	^Sol.Grammar.Init new: initConf</body><body package="Sol-Parser">buildPlayingPiles:cant	^Sol.AST.PlayingPilesSpec new:cant value</body><body package="Sol-Parser">buildPockerDeck	^Sol.Grammar.PokerDeck new</body><body package="Sol-Parser">buildSpanishDeck	^Sol.Grammar.SpanishDeck new</body><body package="Sol-Parser">buildTalon: cant turn: turn circular: circ repository: rep	^cant = 0 ifTrue:[^Sol.Grammar.NoTalon new] ifFalse: [^Sol.Grammar.TalonSpec new: cant value turn: turn circular: circ repository: rep]</body><body package="Sol-Parser">buildTalons: spec	^Sol.Grammar.Talons new: spec</body><body package="Sol-Parser">buildWastePiles: cant	^cant value = 0 ifTrue:[^Sol.Grammar.NoWastePiles new] ifFalse:[^Sol.Grammar.WastePilesSpec new:cant value]</body></methods><methods><class-id>Sol.AST.Gold</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'oro'.</body></methods><methods><class-id>Sol.AST.InitAll</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'todos a '.	count printOn: aStream.</body></methods><methods><class-id>Sol.AST.InitAll</class-id> <category>initialization</category><body package="Sol-AST">initialize:cant	count:=cant</body></methods><methods><class-id>Sol.AST.InitAll</class-id> <category>getters</category><body package="Sol-AST">count	^count</body></methods><methods><class-id>Sol.AST.InitAll class</class-id> <category>creation</category><body package="Sol-AST">new: cant	^super new initialize:cant</body></methods><methods><class-id>Sol.AST.Move</class-id> <category>getters</category><body package="Sol-AST">source	^source</body><body package="Sol-AST">target	^target</body></methods><methods><class-id>Sol.AST.Move</class-id> <category>initialization</category><body package="Sol-AST">initialize:p1 to:p2	source:=p1.	target:=p2.</body></methods><methods><class-id>Sol.AST.Move</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'mover '.	source printOn: aStream.	aStream nextPutAll: ' a '.	target printOn: aStream.</body></methods><methods><class-id>Sol.AST.Move class</class-id> <category>creation</category><body package="Sol-AST">new: pile1 to:pile2	^super new initialize:pile1 to:pile2</body></methods><methods><class-id>Sol.AST.RemoveCards</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' sacar cartas'.</body></methods><methods><class-id>Sol.AST.WastePilesSpec</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'pilas auxiliares :'.	aStream nextPutAll: count asString.</body></methods><methods><class-id>Sol.AST.WastePilesSpec</class-id> <category>initialization</category><body package="Sol-AST">initialize:cant	count:=cant</body></methods><methods><class-id>Sol.AST.WastePilesSpec</class-id> <category>getters</category><body package="Sol-AST">count	^count</body></methods><methods><class-id>Sol.AST.WastePilesSpec class</class-id> <category>creation</category><body package="Sol-AST">new: cant	^super new initialize:cant</body></methods><methods><class-id>Sol.ASTNode</class-id> <category>request handling</category><body package="Sol-Parser">doesNotUnderstand: aMessage	^(self isPropertyGetter: aMessage) ifTrue:[		self getProperty: aMessage]	ifFalse:[		(self isPropertySetter: aMessage) ifTrue:[			self setProperty: aMessage]		ifFalse:[super doesNotUnderstand: aMessage]]</body><body package="Sol-Parser">getProperty: aMessage	^properties at: aMessage selector asString</body><body package="Sol-Parser">getPropertyFromSetterMessage: aMessage	|selector|	"takeWhile"	selector := aMessage selector copyFrom: 1 to: (aMessage selector size - 1).	^selector</body><body package="Sol-Parser">isPropertyGetter: aMessage	[properties at: aMessage selector asString] on: KeyNotFoundError do:[:e | ^false].	^true</body><body package="Sol-Parser">isPropertySetter: aMessage	[properties at: (self getPropertyFromSetterMessage: aMessage)] on: KeyNotFoundError do:[:e | ^false].	^true</body><body package="Sol-Parser">setProperty: aMessage	properties at: (self getPropertyFromSetterMessage: aMessage) put: aMessage arguments first</body></methods><methods><class-id>Sol.ASTNode</class-id> <category>accessing</category><body package="Sol-Parser">accept: aVisitor	^aVisitor perform: ('visit',self nodeName, ':') asSymbol with:self</body><body package="Sol-Parser">nodeName	^name</body></methods><methods><class-id>Sol.ASTNode</class-id> <category>initializing</category><body package="Sol-Parser">initialize: aString properties: aStringsCollection	name := aString.	properties := Dictionary new.	aStringsCollection do:[:propName | 		properties at: propName put: nil ]</body></methods><methods><class-id>Sol.ASTNode class</class-id> <category>instance creation</category><body package="Sol-Parser">named: aString properties: aStringsCollection	^super new initialize: aString properties: aStringsCollection</body></methods><methods><class-id>Sol.TracerGrammarBuilder</class-id> <category>any</category><body package="Sol-Parser">doesNotUnderstand: aMessage	Transcript show: aMessage selector.	Transcript cr.</body></methods><methods><class-id>Sol.AST.Init</class-id> <category>initialization</category><body package="Sol-AST">initialize: initConf	configuration:= initConf</body></methods><methods><class-id>Sol.AST.Init</class-id> <category>getters</category><body package="Sol-AST">configuration	^configuration</body></methods><methods><class-id>Sol.AST.Init</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'Inicio ='. 	aStream cr.	configuration do:[:c| c printOn: aStream. aStream cr.]</body></methods><methods><class-id>Sol.AST.Init class</class-id> <category>creation</category><body package="Sol-AST">new: initConf	^super new initialize: initConf</body></methods><methods><class-id>Sol.CardsStack</class-id> <category>accessing</category><body package="Sol-Model">addCard: aCard	self cards addLast: aCard.	self triggerEvent: #cardsAdded with: (OrderedCollection with: aCard)</body><body package="Sol-Model">addCards: newCards	newCards do: [:card | card when: #cardSelected send:#cardSelected to: self with:card].	self cards: self cards,  newCards.	self triggerEvent: #cardsAdded with: newCards</body><body package="Sol-Model">cards	^cards</body><body package="Sol-Model">cards: anObject	cards := anObject</body><body package="Sol-Model">isEmpty	^self cards isEmpty</body><body package="Sol-Model">takeAll	|all|	all := self cards.	cards := OrderedCollection new.	self triggerEvent: #cardsTaken with: all.	^all</body><body package="Sol-Model">takeCards: aNumber	|c|	c := OrderedCollection new.	aNumber timesRepeat: [ c add: self cards removeLast].	self triggerEvent: #cardsTaken with: c.	^c</body><body package="Sol-Model">takeFirstCard	|card|	self isEmpty ifFalse:[ 	card := self cards removeFirst.						self triggerEvent: #cardsTaken with: (OrderedCollection with: card)].	^card</body><body package="Sol-Model">takeLastCard	|card|	self isEmpty ifFalse:[ 	card := self cards removeLast.						self triggerEvent: #cardsTaken with: (OrderedCollection with: card)].	^card</body></methods><methods><class-id>Sol.CardsStack</class-id> <category>initialization</category><body package="Sol-Model">initialize: initCards	cards := initCards</body></methods><methods><class-id>Sol.CardsStack class</class-id> <category>instance creation</category><body package="Sol-Model">new	^ self withCards: OrderedCollection new</body><body package="Sol-Model">withCards: cards	^ super new initialize: cards</body></methods><methods><class-id>Sol.ConfigBuilder</class-id> <category>building</category><body package="Sol-Config">buildList: aList	^aList</body><body package="Sol-Config">buildMapping: aMapping	^aMapping</body><body package="Sol-Config">buildString: aString	^aString</body></methods><methods><class-id>Sol.AST.RemoveFromTalonHeader</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:' sacar del pozo'.</body></methods><methods><class-id>Sol.CanvasController</class-id> <category>events</category><body package="Sol-UI">mouseMovedEvent: event	Cursor normal show.</body></methods><methods><class-id>Sol.AST.Pile_Variable</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	pile printOn: aStream.	var printOn: aStream.</body><body package="Sol-AST">printOperation:aStream	aStream nextPutAll: ' || '</body></methods><methods><class-id>Sol.AST.Pile_Variable</class-id> <category>initialization</category><body package="Sol-AST">initialize: p variable: v	pile:=p.	var:= v.</body></methods><methods><class-id>Sol.AST.Pile_Variable</class-id> <category>getters</category><body package="Sol-AST">pile	^pile</body><body package="Sol-AST">variable	^var</body></methods><methods><class-id>Sol.AST.Pile_Variable class</class-id> <category>creation</category><body package="Sol-AST">new: p variable: v	^super new initialize: p variable: v</body></methods><methods><class-id>Sol.AST.Rule</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	self print:aStream.	description do:[:line| line printOn:aStream. aStream cr.].</body></methods><methods><class-id>Sol.AST.Rule</class-id> <category>getters</category><body package="Sol-AST">description	^description</body></methods><methods><class-id>Sol.AST.Rule</class-id> <category>setters</category><body package="Sol-AST">description:desc	description:=desc.</body></methods><methods><class-id>Sol.AST.Rule</class-id> <category>initialization</category><body package="Sol-AST">initialize: desc	description:= desc</body></methods><methods><class-id>Sol.AST.Rule class</class-id> <category>creation</category><body package="Sol-AST">new: desc	^super new initialize:desc</body></methods><methods><class-id>Sol.AST.LoseRule</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'perder: '.	description printOn:aStream.</body></methods><methods><class-id>Sol.AST.CommonRule</class-id> <category>initialization</category><body package="Sol-AST"> initialize:enc description:desc	header:=enc.	description:=desc.</body></methods><methods><class-id>Sol.AST.CommonRule</class-id> <category>getters</category><body package="Sol-AST">header	^header</body></methods><methods><class-id>Sol.AST.CommonRule</class-id> <category>printing</category><body package="Sol-AST">print: aStream	header printOn:aStream.	aStream nextPutAll:': '.</body></methods><methods><class-id>Sol.AST.CommonRule class</class-id> <category>creation</category><body package="Sol-AST">new: enc description:desc	^super new initialize:enc description:desc</body></methods><methods><class-id>Sol.DraggableCardFocusTracker</class-id> <category>events</category><body package="Sol-UI">finish	Cursor currentCursor: Cursor normal.self sensor ungrabMouseEventFor: self.														controller :=nil</body><body package="Sol-UI">mouseMovedEvent: event	self initialized not ifTrue:[self getInitialized: event].	(self view containsPoint: self sensor mousePoint) ifFalse:[self finish].	^nil</body><body package="Sol-UI">redButtonPressedEvent: event	|c|	c := self controller.	self finish.	c redButtonPressedEvent: event</body><body package="Sol-UI">redButtonReleasedEvent: event	^nil</body></methods><methods><class-id>Sol.DraggableCardFocusTracker</class-id> <category>initialization</category><body package="Sol-UI">getInitialized: event	self sensor grabMouseEventFor: self.	initialized := true</body></methods><methods><class-id>Sol.DraggableCardFocusTracker</class-id> <category>accessing</category><body package="Sol-UI">initialized	^initialized isNil not</body><body package="Sol-UI">initialized: anObject	initialized := anObject</body></methods><methods><class-id>Sol.AST.NoTalon</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:' pozos: 0'.</body></methods><methods><class-id>Sol.AST.Decks</class-id> <category>initialization</category><body package="Sol-AST"> initialize:cant type:tipo	count:=cant.	type:=tipo.</body></methods><methods><class-id>Sol.AST.Decks</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'mazos :'.	count printOn: aStream.	type printOn: aStream.</body></methods><methods><class-id>Sol.AST.Decks</class-id> <category>getters</category><body package="Sol-AST">count	^count</body><body package="Sol-AST">type	^type</body></methods><methods><class-id>Sol.AST.Decks class</class-id> <category>creation</category><body package="Sol-AST">new:cant type:tipo	^super new initialize:cant type:tipo</body></methods><methods><class-id>Sol.ASTNodeTest</class-id> <category>testing</category><body package="Sol-Tests">testRequestHandler	node name: 'main_deck'.	self shouldnt: [node name: 'main_deck'] raise: Exception.	self assert: (node name = 'main_deck').	"Test the visitor"	self assert: (node accept: self) = 'visited'</body><body package="Sol-Tests">visitdeck: aDeck	^'visited'</body></methods><methods><class-id>Sol.ASTNodeTest</class-id> <category>creation</category><body package="Sol-Tests">setUp	node := ASTNode named: #deck properties: #('type' 'name')</body><body package="Sol-Tests">tearDown	node := nil</body></methods><methods><class-id>Sol.ChainTest</class-id> <category>initializing</category><body package="Sol-Tests">setUp	chain := Chain new.	chain addTarget: HandlerA  new.	chain addTarget: HandlerB new</body><body package="Sol-Tests">tearDown	chain := nil</body></methods><methods><class-id>Sol.ChainTest</class-id> <category>test</category><body package="Sol-Tests">testHandling	self assert: chain handleA = 'A'.	self assert: chain handleB = 'B'.</body></methods><methods><class-id>VisualComponent</class-id> <category>initializing</category><body package="Sol-UI">initialize: aModel controller: aController window: aWindow	model := aModel.	controller := aController.	window := aWindow</body></methods><methods><class-id>VisualComponent class</class-id> <category>instance creation</category><body package="Sol-UI">model: aModel controller: aController window: aWindow	^super new initialize: aModel controller: aController window: aWindow</body></methods><methods><class-id>Sol.AST.UndoAction</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'deshacer'.</body></methods><methods><class-id>Sol.XMLConfigReaderTest</class-id> <category>config</category><body package="Sol-Tests">setUp	| parser |	super setUp.	testFile := '.\tests\xml_config_reader_test.xml'.	parser := XML.XMLParser new.	parser validate: false.	doc := parser parse:testFile.</body><body package="Sol-Tests">tearDown	doc := nil</body></methods><methods><class-id>Sol.XMLConfigReaderTest</class-id> <category>test</category><body package="Sol-Tests">testElementData	self assert: (XMLConfigReader new elementData: (doc root elementNamed:'data_element')) = 'data'</body><body package="Sol-Tests">testIsDataElement	self assert: (XMLConfigReader new isDataElement: doc root) not.	self assert: (XMLConfigReader new isDataElement: (doc root elementNamed:'data_element')).</body><body package="Sol-Tests">testIsListOfElements	self assert: (XMLConfigReader new isListOfElements: doc root) not.	self assert: (XMLConfigReader new isListOfElements: (doc root elementNamed:'data_element')) not.	self assert: (XMLConfigReader new isListOfElements: (doc root elementNamed:'list_of_elements')).</body><body package="Sol-Tests">testRead	| config |	config := (XMLConfigReader on: testFile) read.	self assert: (config at: 'data_element') = 'data'.	self assert: (config at: 'list_of_elements') first = 'elem_1'</body></methods><methods><class-id>Sol.AST.Rough</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' basto'.</body></methods><methods><class-id>Sol.TupleObjectTest</class-id> <category>all</category><body package="Sol-Tests">testAddProperty	|to|	to := TupleObject new.	to addProperty: #name value: 'Mariano'.	self assert:(to name = 'Mariano').</body></methods><methods><class-id>Sol.AST.PokerDeck</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'pocker'.</body></methods><methods><class-id>Sol.DeckClassConfigProxy</class-id> <category>accessing</category><body package="Sol-Config">cardsPerSuit	^cardsPerSuit</body><body package="Sol-Config">cardsPerSuit: anObject	cardsPerSuit := anObject</body><body package="Sol-Config">name	^name</body><body package="Sol-Config">name: anObject	name := anObject</body><body package="Sol-Config">suits	^suits</body><body package="Sol-Config">suits: anObject	suits := anObject</body></methods><methods><class-id>Sol.DeckClassConfigProxy</class-id> <category>instance creation</category><body package="Sol-Config">initialize: _name suits: _suits cardsPerSuit: cards	name := _name.	suits := _suits.	cardsPerSuit := cards</body></methods><methods><class-id>Sol.DeckClassConfigProxy class</class-id> <category>instance creation</category><body package="Sol-Config">name: _name suits: suits cardsPerSuit: cards	^super new initialize: _name suits: suits cardsPerSuit: cards</body></methods><methods><class-id>Sol.AST.PreviousCardType</class-id> <category>getters</category><body package="Sol-AST">type	^type</body></methods><methods><class-id>Sol.AST.PreviousCardType</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' anterior('.	type printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.PreviousCardType</class-id> <category>initialization</category><body package="Sol-AST">initialize: t	type:=t.</body></methods><methods><class-id>Sol.AST.PreviousCardType class</class-id> <category>creation</category><body package="Sol-AST">new: type	^super new initialize: type</body></methods><methods><class-id>Sol.SolFactory</class-id> <category>creation</category><body package="Sol-Model">newDeck: deckType conf: conf	"Crea un mazo segun la configuracion"	"La configuracion contiene informacion sobre las clases de mazos y valoraciones que le da el juego a las cartas (chain of responsibility?)"	"Probablemente conf sea una cadena de dos ConfigProxies, uno para acceder a la configuracion de las clases, el otro para la configuracion de la aplicacion"	"Esta bien que el parametro de configuracion sea uno solo. Este metodo no es responsable de distinguir entre configuraciones, la configuracion mandada"	"debe ser una configuracion compuesta"		| deckTypeInfo card value deck |		deck := Deck type: deckType suits: conf suits cardsPerSuit: conf cardsPerSuit.	deckTypeInfo := conf deckType: deckType.		"Crear cada una de las cartas segun la configuracion"	deckTypeInfo suits do:[:suit |		deckTypeInfo cardsPerSuit do:[:cardName |			value := conf cardValue: cardName.			card := Card name: cardName value: value suit: suit deck: deck. 			deck addCard: card ]].	"Crear los comodines"	deckTypeInfo jokesCant timesRepeat:[			value := conf cardValue: #joke.			card := Card name: #joke value: value suit: #jokes deck: deck. 			deck addCard: card ].	^ deck</body></methods><methods><class-id>Sol.PileController</class-id> <category>events</category><body package="Sol-UI">cardClicked: aCard event: evt	|taken tracker pv|	Transcript show: aCard printString, ' clicked '; cr.	(self model canTakeFrom: aCard) ifTrue: [		taken := self model takeFrom: aCard.		pv := PileView on: (Pile withCards: taken).		tracker := CardsTracker track: (BoundedWrapper on: pv at: 0@0) on: self.		pv layout: self view layout.		tracker handleEvent: evt]</body><body package="Sol-UI">downcastLocalEvent: event with: arg at: aPoint from: anInitiator	event = #cardsDrop ifFalse:[^super downcastLocalEvent: event with: arg at: aPoint from: anInitiator].	(self view containsPoint: aPoint) ifFalse: [^false].	arg value value: self model.</body></methods><methods><class-id>Sol.PileController</class-id> <category>private</category><body package="Sol-UI">selectionTracker	^CardsTracker on: self</body></methods><methods><class-id>Sol.Pile</class-id> <category>accessing</category><body package="Sol-Model">canAddCards: c	"Returns if its posible to add cards to the pile"	^true</body><body package="Sol-Model">canTakeFrom: aCard	"Returns if it is posible to remove cards from aCard from the pile"	^true</body><body package="Sol-Model">takeFrom: aCard	|removing removed|	removing := false.	removed := OrderedCollection new.	self cards do: [:card | removing ifTrue:[removed add: card]						ifFalse: [card = aCard ifTrue: [removing := true. removed add: card]]].	self cards removeAll: removed.	self triggerEvent: #cardsTaken with: removed.	^removed</body></methods><methods><class-id>Sol.ConfigProxy</class-id> <category>initializing</category><body package="Sol-Config">initialize: aConfiguration	config := aConfiguration</body></methods><methods><class-id>Sol.ConfigProxy</class-id> <category>accessing</category><body package="Sol-Config">config	^config</body></methods><methods><class-id>Sol.ConfigProxy class</class-id> <category>instance creation</category><body package="Sol-Config">on: aConfiguration	^super new initialize: aConfiguration</body></methods><methods><class-id>Sol.AST.Configuration</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'Configuración='.	aStream cr.	decks printOn: aStream.	aStream cr.	wastePiles printOn: aStream.	aStream cr.	talons printOn: aStream.	aStream cr.	foundations printOn: aStream.	aStream cr.	playingPiles printOn: aStream.	aStream cr.</body></methods><methods><class-id>Sol.AST.Configuration</class-id> <category>getters</category><body package="Sol-AST">decks^decks</body><body package="Sol-AST">foundations	^foundations</body><body package="Sol-AST">playingPiles	^playingPiles</body><body package="Sol-AST">talons	^talons</body><body package="Sol-AST">wastePiles	^wastePiles</body></methods><methods><class-id>Sol.AST.Configuration</class-id> <category>initialization</category><body package="Sol-AST">initialize: decks_ wastePiles: wastePiles_ talons: talons_ foundations: foundations_ playingPiles: playingPiles_	decks:=decks_.	wastePiles:=wastePiles_.	talons:=talons_.	foundations:=foundations_.	playingPiles:=playingPiles_.</body></methods><methods><class-id>Sol.AST.Configuration class</class-id> <category>creation</category><body package="Sol-AST">new: decks wastePiles: wastePiles talons: talons foundations: foundations playingPiles: playingPiles	^super new initialize: decks wastePiles: wastePiles talons: talons foundations: foundations playingPiles: playingPiles</body></methods><methods><class-id>Sol.CardsDistributor</class-id> <category>accessing</category><body package="Sol-Model">give: aNumber from: aDeck to: otherPile	mode = #random ifTrue:[aDeck mix].	aDeck cards size &lt; aNumber ifTrue:[self error:'faltan cartas'].	otherPile addCards: (aDeck takeCards: aNumber)</body><body package="Sol-Model">mode	^mode</body><body package="Sol-Model">mode: anObject	mode := anObject</body></methods><methods><class-id>Sol.CardsDistributor</class-id> <category>initialization</category><body package="Sol-Model">initialize: aMode	mode := aMode.</body></methods><methods><class-id>Sol.CardsDistributor class</class-id> <category>instance creation</category><body package="Sol-Model">mode: aMode	^super new initialize: aMode</body><body package="Sol-Model">new	self error: 'Crear con mode: aMode'</body></methods><methods><class-id>Sol.ImageView</class-id> <category>displaying</category><body package="Sol-UI">displayOn: aGraphicsContext	self image displayOn: aGraphicsContext</body></methods><methods><class-id>Sol.ImageView</class-id> <category>accessing</category><body package="Sol-UI">image	^image</body><body package="Sol-UI">image: anObject	image := anObject</body></methods><methods><class-id>Sol.ImageView</class-id> <category>object initialization</category><body package="Sol-UI">initialize: aModel	model := aModel.	image := self initializeImage: aModel.</body></methods><methods><class-id>Sol.ImageView</class-id> <category>bounds</category><body package="Sol-UI">preferredBounds	^(0@0) extent: (self image width @ self image height )</body></methods><methods><class-id>Sol.ImageView class</class-id> <category>instance creation</category><body package="Sol-UI">on: aModel	^self new initialize: aModel</body></methods><methods><class-id>Sol.CardView</class-id> <category>private</category><body package="Sol-UI">defaultControllerClass	^CardController</body></methods><methods><class-id>Sol.CardView</class-id> <category>object initialization</category><body package="Sol-UI">initializeImage: aCard	^(ImageReader fromFile: (aCard deck cardset imageFileFor: aCard)) image</body></methods><methods><class-id>Sol.CardView</class-id> <category>moving</category><body package="Sol-UI">moveOffset: anOffsetPoint	|bw |	bw := self container.	self invalidate.	bw bounds: ((bw bounds origin + anOffsetPoint) extent: bw bounds extent).	"Window activeController view topComponent display."</body><body package="Sol-UI">moveRelativeTo: aFractionalPoint	|bw origin w|	bw := self container.	self invalidate.	w := Window activeController view topComponent.	origin := (aFractionalPoint x * (w displayBox width)) @ (aFractionalPoint y * (w displayBox height)).	bw bounds: (origin extent: bw bounds extent).	"w display"</body><body package="Sol-UI">moveTo: aPoint	|bw |	bw := self container.	self invalidate.	bw bounds: (aPoint extent: bw bounds extent).	"Window activeController view topComponent display."</body></methods><methods><class-id>Sol.TalonView</class-id> <category>accessing</category><body package="Sol-UI">backImage	^backImage</body><body package="Sol-UI">backImage: anObject	backImage := anObject</body><body package="Sol-UI">emptyImage	^emptyImage</body><body package="Sol-UI">emptyImage: anObject	emptyImage := anObject</body></methods><methods><class-id>Sol.TalonView</class-id> <category>controller accessing</category><body package="Sol-UI">defaultControllerClass	^TalonController</body></methods><methods><class-id>Sol.TalonView</class-id> <category>initialization</category><body package="Sol-UI">initialize: aTalon	super initialize: aTalon.	self model when: #cardsTaken send: #talonChanged to: self</body><body package="Sol-UI">initializeImage: aTalon	backImage := (ImageReader fromFile: self backImageFile) image.	emptyImage := (ImageReader fromFile:'./cards/cardset-standard/bottom01.gif') image.	aTalon isEmpty ifTrue: [^emptyImage]					ifFalse:[^backImage]</body></methods><methods><class-id>Sol.TalonView</class-id> <category>events</category><body package="Sol-UI">talonChanged	self model isEmpty ifTrue: [self image: self emptyImage]	ifFalse:[self image: self backImage].	self invalidate.</body></methods><methods><class-id>Sol.Talon</class-id> <category>accessing</category><body package="Sol-Model">cardsManager	^cardsManager</body><body package="Sol-Model">takeAmount	^takeAmount</body><body package="Sol-Model">takeAmount: anObject	takeAmount := anObject</body><body package="Sol-Model">takeCards	"viene del UI"	self cardsManager takeCardsFromTalon: self</body></methods><methods><class-id>Sol.Talon</class-id> <category>initialization</category><body package="Sol-Model">initializeWith: c take: aNumber cardsManager: aCardsManager	super initialize: c.	cardsManager := aCardsManager.	takeAmount := aNumber</body></methods><methods><class-id>Sol.Talon class</class-id> <category>instance creation</category><body package="Sol-Model">withCards: cards take: aNumber  cardsManager: aCardsManager	"cardManager es un objeto que se encarga de lo que hay que hacer con la carta tomada"	"seguramente sea la aplicacion"	^super new initializeWith: cards take: aNumber cardsManager: aCardsManager</body></methods><methods><class-id>Sol.DeckClassesConfigProxyTest</class-id> <category>test</category><body package="Sol-Tests">setUp	testFile:= '.\src\deck_classes.xml'.	proxy := Sol.DeckClassesConfigProxy on: (Sol.XMLConfigReader on: testFile) read</body><body package="Sol-Tests">testDeckClassNamed	self assert:(proxy deckClassNamed: 'Pocker') name = 'Pocker'.	self should: [(proxy deckClassNamed: 'none') name = 'none'] raise: Error</body></methods><methods><class-id>Sol.DeckVisualStyle class</class-id> <category>cards image files</category><body package="Sol-UI">cardImageFiles	"Retorna un diccionario con carta -&gt; nombre_de_archivo"	"Método standard, redefinir en las subclases o configurar para obtener desde un archivo"	| suitLetter numberStr dict |	dict := Dictionary new.	self cards do: [:card |		suitLetter := card suit asString first asSymbol.		numberStr := card number &lt; 10 ifTrue:['0'] ifFalse:[''].		numberStr := numberStr, card number printString.		dict at: card put: self path ,  self directorySeparator , numberStr , suitLetter , '.' , self fileExtension]</body><body package="Sol-UI">cards	"Devuelve la lista de cartas segun el tipo de mazo"	^self subclassResponsibility</body><body package="Sol-UI">directorySeparator	^'\'</body><body package="Sol-UI">fileExtension	^'gif'</body><body package="Sol-UI">imageFileFor: aCard	"Retorna el nombre del archivo de imagen dada una carta"	^self cardImageFiles at: aCard</body><body package="Sol-UI">imageFor: aCard	"Devuelve la imagen para una carta"	|f|	f := self imageFileFor: aCard.	aCard image: (ImageReader fromFile: f)</body></methods><methods><class-id>Sol.CardController</class-id> <category>events</category><body package="Sol-UI">giveFeedback: effect dataSource: ds	self view image displayOn: self window graphicsContext at: self window sensor mousePoint.	^false</body><body package="Sol-UI">queryContinueDragging: ds with: s	^#continue</body><body package="Sol-UI">selectionTracker	^CardsTracker on:self</body></methods><methods><class-id>Sol.CardController</class-id> <category>initializing</category><body package="Sol-UI">initialize: aWindow	super initialize.	window := aWindow</body></methods><methods><class-id>Sol.CardController</class-id> <category>accessing</category><body package="Sol-UI">window	^window</body><body package="Sol-UI">window: anObject	window := anObject</body></methods><methods><class-id>Sol.CardController class</class-id> <category>instance creation</category><body package="Sol-UI">new	^ super new initialize: Window currentWindow</body><body package="Sol-UI">new: aWindow	^ super new initialize: aWindow</body></methods><methods><class-id>Sol.AST.DescriptionLine</class-id> <category>getters</category><body package="Sol-AST">actions	^actions</body><body package="Sol-AST">conditions	^conditions</body></methods><methods><class-id>Sol.AST.DescriptionLine</class-id> <category>initialization</category><body package="Sol-AST">initialize: cond actions:act	conditions:=cond.	actions:=act.</body></methods><methods><class-id>Sol.AST.DescriptionLine</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll:'si ('.	conditions printOn:aStream.	aStream nextPutAll:')'.	aStream cr.	aStream nextPutAll:'entonces '.	actions printOn:aStream.</body></methods><methods><class-id>Sol.AST.DescriptionLine class</class-id> <category>creation</category><body package="Sol-AST">new: cond actions:act	^super new initialize: cond actions:act</body></methods><methods><class-id>Sol.SolApplication</class-id> <category>interface opening</category><body package="Sol-Model">buildPlayingPiles: aBuilder	|x y pv layout pw |	x := 0.	y := 100.	layout := self playingPilesLayoutClass new.	self piles do: [:pile | 	pv := PileView on: pile.						pw := self canvas addWrapper: (BoundedWrapper on: pv at: x@y).						pv layout: layout.						x := x + pw bounds extent x + 10.					    ]</body><body package="Sol-Model">buildRepository: aBuilder	|pv bw layout|	self repository isNil ifTrue:[^nil].	layout := self repositoryLayoutClass new.	pv := PileView on: self repository.	bw := BoundedWrapper on: pv at: 100@0.	pv layout: layout.	self canvas addWrapper: bw.</body><body package="Sol-Model">buildTalon: aBuilder	|tv|	tv := BoundedWrapper on: (TalonView on: self talon) at: 0@0.	"tv component controller model: self."	"cambio el modelo que recibe los eventos"	self canvas addWrapper: tv.</body><body package="Sol-Model">playingPilesViewClass	^self subclassResponsibility</body><body package="Sol-Model">postBuildWith: aBuilder	self buildTalon: aBuilder.	self buildRepository: aBuilder.	self buildPlayingPiles: aBuilder</body></methods><methods><class-id>Sol.SolApplication</class-id> <category>accessing</category><body package="Sol-Model">canvas	^canvas</body><body package="Sol-Model">canvas: anObject	canvas := anObject</body><body package="Sol-Model">deck	deck isNil ifFalse:[^deck].	self error: 'Error accediendo al mazo. Probablemente haya mas de uno, acceder con decks'</body><body package="Sol-Model">deck: anObject	deck := anObject</body><body package="Sol-Model">distributor	^distributor</body><body package="Sol-Model">distributor: anObject	distributor := anObject</body><body package="Sol-Model">piles	^piles</body><body package="Sol-Model">piles: anObject	piles := anObject</body><body package="Sol-Model">repository	^repository</body><body package="Sol-Model">repository: anObject	repository := anObject</body><body package="Sol-Model">solName	^solName</body><body package="Sol-Model">solName: anObject	solName := anObject</body><body package="Sol-Model">talon	^talon</body><body package="Sol-Model">talon: anObject	talon := anObject</body></methods><methods><class-id>Sol.SolApplication</class-id> <category>initialization</category><body package="Sol-Model">addDeck: _deck 	decks at: _deck name put: (factory newDeck: deck type)</body><body package="Sol-Model">begin	"Los metodos que usan rules al nivel de SolApplication interpretan las reglas"	"Estos metodos pueden ser sobreescritos en la aplicacion subclase con codigo Smalltalk compilado a partir de la configuracion"	conf beginRules do:[:rule | 		self executeRule: rule]</body><body package="Sol-Model">deckNamed: aString	^decks at: aString</body><body package="Sol-Model">initialize: _conf factory: _factory	conf := _conf.	factory := _factory.	solName := _conf solName.	canvas := _factory newCanvas.	self initializeDecks.	self initializePiles.	self initializeTalon.	self initializeRepository.	self initializeEvents</body><body package="Sol-Model">initializeDecks	"Inicializa el mazo o los mazos de la aplicacion en base a la configuracion en params"	decks := Dictionary new.	conf decks do:[:_deck |  		"Crear cada mazo"		self addDeck: _deck ]</body><body package="Sol-Model">initializeEvents	"self talon when: #cardsTaken send: #talonCardTaken: to: self"</body><body package="Sol-Model">initializePiles	piles := conf piles collect:[:pileDef |  		factory newPile: pileDef]</body><body package="Sol-Model">initializeRepository	repository := factory newRepository: conf repository</body><body package="Sol-Model">initializeTalon	talon := factory newTalon: conf talon</body></methods><methods><class-id>Sol.SolApplication</class-id> <category>events</category><body package="Sol-Model">takeCardsFromTalon: aTalon	^self subclassResponsibility</body><body package="Sol-Model">takeFromTalon</body></methods><methods><class-id>Sol.SolApplication class</class-id> <category>instance creation</category><body package="Sol-Model">new	^ super shouldNotImplement</body><body package="Sol-Model">with: initParams factory: factory	"initParams son parametros de configuracion. Se agrupan todos en un solo objeto para no tener que modificar el protocolo, de este metodo entre otros."	^super new initialize: initParams factory: factory</body></methods><methods><class-id>Sol.AST.WinRule</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'ganar: '.	description printOn:aStream.</body></methods><methods><class-id>Sol.AST.False</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'F'.</body></methods><methods><class-id>Sol.AST.EmptyPile</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'vacia ('.	pile printOn:aStream.	aStream nextPutAll:')'.</body></methods><methods><class-id>Sol.AST.EmptyPile</class-id> <category>initialization</category><body package="Sol-AST">initialize:p	pile:=p.</body></methods><methods><class-id>Sol.AST.EmptyPile</class-id> <category>getters</category><body package="Sol-AST">pile	^pile</body></methods><methods><class-id>Sol.AST.EmptyPile class</class-id> <category>creation</category><body package="Sol-AST">new:p	^super new initialize:p</body></methods><methods><class-id>Sol.AST.True</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'V'.</body></methods><methods><class-id>Sol.AST.ForEach</class-id> <category>getters</category><body package="Sol-AST">conditions	^conditions</body><body package="Sol-AST">pile	^pile</body><body package="Sol-AST">variable	^variable</body></methods><methods><class-id>Sol.AST.ForEach</class-id> <category>initialization</category><body package="Sol-AST">initialize: p using: v check:cond	pile:=p.	variable:=v.	conditions:=cond.</body></methods><methods><class-id>Sol.AST.ForEach</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	self print:aStream.	aStream nextPutAll:'-para-cada ('.	pile printOn: aStream.	aStream nextPutAll:' '.	variable printOn: aStream.	aStream nextPutAll:' ) ['.	conditions printOn: aStream.	aStream nextPutAll:' ]'.</body></methods><methods><class-id>Sol.AST.ForEach class</class-id> <category>creation</category><body package="Sol-AST">new:p using: v check:cond	^super new initialize: p using: v check:cond</body></methods><methods><class-id>Sol.AST.OrForEach</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:'o'.</body></methods><methods><class-id>Sol.AST.AndForEach</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:'y'.</body></methods><methods><class-id>Sol.PileView</class-id> <category>accessing</category><body package="Sol-UI">bottomImage	^bottomImage</body><body package="Sol-UI">bottomImage: anObject	bottomImage := anObject</body><body package="Sol-UI">layout	^layout</body><body package="Sol-UI">layout: anObject	layout := anObject.	self rebuild</body><body package="Sol-UI">separation	^separation</body><body package="Sol-UI">separation: anObject	separation := anObject.	self rebuild</body></methods><methods><class-id>Sol.PileView</class-id> <category>initialization</category><body package="Sol-UI">buildBottom	self addWrapper: (BoundedWrapper on: bottomImage at: 0@0).</body><body package="Sol-UI">buildCardViews	|bw x y c|	x := 0. y := 0.	self model cards do:[:card | c := CardView on: card.								c controller: (PileCardController owner: self controller).								bw := BoundedWrapper on: c at: x@y.								self addWrapper: bw.								x := self layout nextX: x sep: self separation.								y := self layout nextY: y sep: self separation]</body><body package="Sol-UI">initialize: aPile layout: aLayout sep: aNumber	self model: aPile.	self initializeEvents.	separation := aNumber.	layout := aLayout.	bottomImage := self initializeBottomImage.	self buildBottom.	self buildCardViews</body><body package="Sol-UI">initializeBottomImage	^(ImageReader fromFile:'./cards/cardset-standard/bottom01.gif') image</body><body package="Sol-UI">initializeEvents	self model when: #cardsTaken send: #pileChanged: to: self.	self model when: #cardsAdded send: #pileChanged:  to: self.</body></methods><methods><class-id>Sol.PileView</class-id> <category>controller accessing</category><body package="Sol-UI">defaultControllerClass	^PileController</body></methods><methods><class-id>Sol.PileView</class-id> <category>events</category><body package="Sol-UI">pileChanged: cards	self rebuild</body><body package="Sol-UI">rebuild	self releaseAllComponents.	self buildBottom.	self buildCardViews.	self container bounds: (self container bounds origin extent: self computePreferredBounds extent).	self invalidate</body></methods><methods><class-id>Sol.PileView class</class-id> <category>instance creation</category><body package="Sol-UI">horizontalOn: aPile	^self on: aPile layout: HorizontalPileLayout new sep: 20</body><body package="Sol-UI">on: aPile	^self on: aPile layout: FlatPileLayout new sep: 20</body><body package="Sol-UI">on: aPile layout: aLayout sep: aNumber	^super new initialize: aPile layout: aLayout sep: aNumber</body><body package="Sol-UI">verticalOn: aPile	^self on: aPile layout: VerticalPileLayout new sep: 20</body></methods><methods><class-id>Sol.AST.Heart</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'corazón'.</body></methods><methods><class-id>Sol.Canvas</class-id> <category>controller</category><body package="Sol-UI">defaultControllerClass	^CanvasController</body></methods><methods><class-id>Sol.CardsTracker</class-id> <category>accessing</category><body package="Sol-UI">background	^background</body><body package="Sol-UI">background: anObject	background := anObject</body><body package="Sol-UI">visualObject	^visualObject</body><body package="Sol-UI">visualObject: anObject	visualObject := anObject</body></methods><methods><class-id>Sol.CardsTracker</class-id> <category>initialization</category><body package="Sol-UI">initialize: aVisualObject on: aController	controller := aController.	visualObject := aVisualObject.</body><body package="Sol-UI">initializeBackground: aPoint	| ext location |	ext := self visualObject bounds extent.	location := aPoint.	background := (self window graphicsContext paintBasis retainedMediumWithExtent: ext) graphicsContext.	background copyArea: background clippingBounds			from: self window graphicsContext			sourceOffset: location			destinationOffset: 0@0.	background translation: location.</body></methods><methods><class-id>Sol.CardsTracker</class-id> <category>private</category><body package="Sol-UI">changeCursor	Cursor currentCursor: Cursor hand.</body><body package="Sol-UI">finishSelectionFor: aPoint	|dropPile cards|	self restoreCursor.	self window isNil ifFalse:	[		self background medium displayOn: self window graphicsContext at: self background translation.		dropPile := self window findPileInterestedInDrop: self model at: self window sensor mousePoint].	cards := self visualObject component model cards.	dropPile = nil 		ifFalse:[			(self canAddCards:  cards dropPile: dropPile) 				ifTrue: [self addCards: cards model: dropPile. ^nil]].	self model addCards: cards.</body><body package="Sol-UI">restoreCursor	Cursor currentCursor: Cursor normal.</body><body package="Sol-UI"> trackSelectionFor: aPoint	"aPoint is relative to the card"	|pt|	self window isNil ifTrue:[^nil].	pt := self window sensor mousePoint.	self background isNil ifTrue:[	self changeCursor.								self controller view repairDamage.								self initializeBackground: pt. 								self visualObject displayOn: self window graphicsContext at: pt].	self visualObject moveTo: pt on: self window graphicsContext restoring: self background.</body><body package="Sol-UI">window	^Window currentWindow</body></methods><methods><class-id>Sol.CardsTracker class</class-id> <category>instance creation</category><body package="Sol-UI">track: aVisualObject on: aController	^self new initialize: aVisualObject on: aController</body></methods><methods><class-id>Sol.AST.NextCardType</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' siguiente('.	type printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.NextCardType</class-id> <category>initialization</category><body package="Sol-AST">initialize: t	type:=t.</body></methods><methods><class-id>Sol.AST.NextCardType</class-id> <category>getters</category><body package="Sol-AST">type	^type</body></methods><methods><class-id>Sol.AST.NextCardType class</class-id> <category>creation</category><body package="Sol-AST">new: type	^super new initialize: type</body></methods><methods><class-id>Sol.AST.CardSuit</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll:' palo('.	card printOn:aStream.	aStream nextPutAll:')'.</body></methods><methods><class-id>Sol.AST.CardSuit</class-id> <category>getters</category><body package="Sol-AST">card	^card</body></methods><methods><class-id>Sol.AST.CardSuit</class-id> <category>initialization</category><body package="Sol-AST">initialize: c	card:=c.</body></methods><methods><class-id>Sol.AST.CardSuit class</class-id> <category>creation</category><body package="Sol-AST">new: card	^super new initialize: card</body></methods><methods><class-id>Sol.TalonController</class-id> <category>events</category><body package="Sol-UI">redButtonPressedEvent: event	self model takeCards</body></methods><methods><class-id>Sol.AST.TalonSpec</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	count printOn: aStream.	aStream nextPutAll:' ,'.	turn printOn: aStream. 	aStream nextPutAll:' ,'.	circular printOn: aStream. aStream nextPutAll:' ,'.	repository printOn: aStream.</body></methods><methods><class-id>Sol.AST.TalonSpec</class-id> <category>getters</category><body package="Sol-AST">circular	^circular</body><body package="Sol-AST">count	^count</body><body package="Sol-AST">repository	^repository</body><body package="Sol-AST">turn	^turn</body></methods><methods><class-id>Sol.AST.TalonSpec</class-id> <category>initialization</category><body package="Sol-AST">initialize: cant turn: turn_ circular: circ repository: rep	count:=cant.	turn:=turn_.	circular:=circ.	repository:=rep.</body></methods><methods><class-id>Sol.AST.TalonSpec class</class-id> <category>creation</category><body package="Sol-AST">new: cant turn: turn circular: circ repository: rep	^super new initialize: cant turn: turn circular: circ repository: rep</body></methods><methods><class-id>Sol.AST.CardsCountInPilesType</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' cantidad en ('.	pileType printOn:aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.CardsCountInPilesType</class-id> <category>initialization</category><body package="Sol-AST">initialize: pt	pileType:=pt</body></methods><methods><class-id>Sol.AST.CardsCountInPilesType</class-id> <category>getters</category><body package="Sol-AST">pileType	^pileType</body></methods><methods><class-id>Sol.AST.CardsCountInPilesType class</class-id> <category>creation</category><body package="Sol-AST">new: pileType	^super new initialize: pileType</body></methods><methods><class-id>Sol.AST.ArithmeticalOperation</class-id> <category>getters</category><body package="Sol-AST">operand1	^operand1</body><body package="Sol-AST">operand2	^operand2</body></methods><methods><class-id>Sol.AST.ArithmeticalOperation</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	operand1 printOn: aStream.	self print: aStream.	operand2 printOn: aStream.</body></methods><methods><class-id>Sol.AST.ArithmeticalOperation</class-id> <category>initialization</category><body package="Sol-AST">initialize:op1 with:op2	operand1:=op1.	operand2:=op2.</body></methods><methods><class-id>Sol.AST.ArithmeticalOperation class</class-id> <category>creation</category><body package="Sol-AST">new: op1 with: op2	^super new initialize:op1 with:op2</body></methods><methods><class-id>Sol.AST.Mult</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'*'.</body></methods><methods><class-id>Sol.AST.Div</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' / '.</body></methods><methods><class-id>Sol.AST.Minus</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'-'.</body></methods><methods><class-id>Sol.AST.BinaryCondition</class-id> <category>getters</category><body package="Sol-AST">firstCondition	^cond1</body><body package="Sol-AST">secondCondition	^cond2</body></methods><methods><class-id>Sol.AST.BinaryCondition</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'('.	cond1 printOn: aStream.	self printOperation:aStream.	cond2 printOn:aStream.	aStream nextPutAll:')'.</body></methods><methods><class-id>Sol.AST.BinaryCondition</class-id> <category>initialization</category><body package="Sol-AST">initialize:con1 with:con2	cond1:=con1.	cond2:=con2.</body></methods><methods><class-id>Sol.AST.BinaryCondition class</class-id> <category>creation</category><body package="Sol-AST">new:cond1 with:cond2	^super new initialize:cond1 with:cond2</body></methods><methods><class-id>Sol.AST.Variable</class-id> <category>getters</category><body package="Sol-AST">value	^var</body></methods><methods><class-id>Sol.AST.Variable</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	var printOn: aStream.</body></methods><methods><class-id>Sol.AST.Variable</class-id> <category>initialization</category><body package="Sol-AST">initialize: v	var:=v.</body></methods><methods><class-id>Sol.AST.Variable class</class-id> <category>creation</category><body package="Sol-AST">new: value	^super new initialize: value</body></methods><methods><class-id>Sol.AST.Cup</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll:' copa'</body></methods><methods><class-id>Sol.Chain</class-id> <category>handle request</category><body package="Sol-Util">doesNotUnderstand: aMessage	targets do:[:target | 		[^target perform: aMessage selector withArguments: aMessage arguments] on: MessageNotUnderstood do:[:e | nil]]</body></methods><methods><class-id>Sol.Chain</class-id> <category>accessing</category><body package="Sol-Util">addTarget: anObject	targets add: anObject</body></methods><methods><class-id>Sol.Chain</class-id> <category>initializing</category><body package="Sol-Util">initialize	targets := OrderedCollection new</body></methods><methods><class-id>Sol.Chain class</class-id> <category>instance creation</category><body package="Sol-Util">new	^super new initialize</body></methods><methods><class-id>Sol.AST.TurnCards</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'dar vuelta cartas'.</body></methods><methods><class-id>Sol.AST.Talons</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' pozos'.</body></methods><methods><class-id>Sol.AST.Talons</class-id> <category>getters</category><body package="Sol-AST">talons	^talons</body></methods><methods><class-id>Sol.AST.Talons</class-id> <category>initialization</category><body package="Sol-AST">initialize: spec	talons:=spec.</body></methods><methods><class-id>Sol.AST.Talons class</class-id> <category>creation</category><body package="Sol-AST">new: spec	^super new initialize:spec</body></methods><methods><class-id>Sol.AST.Foundations</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:' bases'.</body></methods><methods><class-id>Sol.AST.CardsCountInPile</class-id> <category>initialization</category><body package="Sol-AST">initialize: p	pile:=p</body></methods><methods><class-id>Sol.AST.CardsCountInPile</class-id> <category>getters</category><body package="Sol-AST">pile	^pile</body></methods><methods><class-id>Sol.AST.CardsCountInPile</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' cantidad de cartas ('.	pile printOn:aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.CardsCountInPile class</class-id> <category>creation</category><body package="Sol-AST">new: pile	^super new initialize: pile</body></methods><methods><class-id>Sol.AST.InitRest</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll:'resto'.</body></methods><methods><class-id>Sol.HandlerA</class-id> <category>handle request</category><body package="Sol-Tests">handleA	^'A'</body></methods><methods><class-id>Sol.TupleObject</class-id> <category>properties</category><body package="Sol-Util">addProperty: aString value: anObject	properties at: aString put: anObject</body><body package="Sol-Util">doesNotUnderstand: aMessage	[properties at: aMessage selector] on: KeyNotFoundError do: [:e | ^self error:aMessage selector, ': propiedad no reconocida'].	^properties at: aMessage selector</body></methods><methods><class-id>Sol.TupleObject</class-id> <category>initializing</category><body package="Sol-Util">initialize	properties := Dictionary new</body></methods><methods><class-id>Sol.TupleObject class</class-id> <category>instance creation</category><body package="Sol-Util">new	^super new initialize</body></methods><methods><class-id>Sol.AST.And</class-id> <category>printing</category><body package="Sol-AST">printOperation:aStream	aStream nextPutAll: ' &amp;&amp; '</body></methods><methods><class-id>Sol.AST.GameSpecification</class-id> <category>getters</category><body package="Sol-AST">configuration ^configuration</body><body package="Sol-AST">init	^init</body><body package="Sol-AST">name	^name</body><body package="Sol-AST">rules	^rules</body></methods><methods><class-id>Sol.AST.GameSpecification</class-id> <category>initialization</category><body package="Sol-AST">initialize: nombre init: inicio configuration:configuracion rules: reglas	name:=nombre.	init:=inicio.	configuration:=configuracion.	rules:=reglas.</body></methods><methods><class-id>Sol.AST.GameSpecification</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll:('Nombre = ', name). aStream cr. aStream cr.	configuration printOn: aStream. 	aStream cr.	init printOn:aStream. 	aStream cr.	rules printOn:aStream.</body></methods><methods><class-id>Sol.AST.GameSpecification class</class-id> <category>creation</category><body package="Sol-AST">new: nombre init: inicio configuration:configuracion rules: reglas	^super new initialize: nombre init: inicio configuration:configuracion rules: reglas</body></methods><methods><class-id>Sol.PileCardController</class-id> <category>initialization</category><body package="Sol-UI">initialize: anOwner	owner := anOwner</body></methods><methods><class-id>Sol.PileCardController</class-id> <category>events</category><body package="Sol-UI">mouseMovedEvent: event	(self owner model canTakeFrom: self model) ifTrue:[		(DraggableCardFocusTracker on: self) handleEvent: event.		Cursor currentCursor: Cursor hand	]</body><body package="Sol-UI">redButtonPressedEvent: event	self owner cardClicked: self model event: event</body></methods><methods><class-id>Sol.PileCardController</class-id> <category>accessing</category><body package="Sol-UI">owner	^owner</body><body package="Sol-UI">owner: anObject	owner := anObject</body></methods><methods><class-id>Sol.PileCardController class</class-id> <category>instance creation</category><body package="Sol-UI">owner: anOwner	^super new initialize: anOwner</body></methods><methods><class-id>Sol.AST.Foundation</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:' base'.</body></methods><methods><class-id>Sol.AST.PlayingPile</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:' pila de juego'.</body></methods><methods><class-id>Sol.AST.WastePile</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:' pila auxiliar'.</body></methods><methods><class-id>Sol.AST.Talon</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:' pozo'.</body></methods><methods><class-id>Sol.AST.AllDecks</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' mazos'</body></methods><methods><class-id>Sol.AST.NoWastePiles</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'pilas auxiliares: 0'.</body></methods><methods><class-id>Sol.AST.UnaryCondition</class-id> <category>initialization</category><body package="Sol-AST">initialize:con	cond:=con.</body></methods><methods><class-id>Sol.AST.UnaryCondition</class-id> <category>getters</category><body package="Sol-AST">condition^cond</body></methods><methods><class-id>Sol.AST.UnaryCondition class</class-id> <category>creation</category><body package="Sol-AST">new: cond	^super new initialize:cond</body></methods><methods><class-id>Sol.AST.Not</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'¬('.	cond printOn: aStream.	aStream nextPutAll:')'.</body></methods><methods><class-id>Sol.AST.ListInitValues</class-id> <category>getters</category><body package="Sol-AST">list	^list</body></methods><methods><class-id>Sol.AST.ListInitValues</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	list do:[:v| v printOn: aStream].</body></methods><methods><class-id>Sol.AST.ListInitValues</class-id> <category>initialization</category><body package="Sol-AST">initialize: lista	list:=lista</body></methods><methods><class-id>Sol.AST.ListInitValues class</class-id> <category>creation</category><body package="Sol-AST">new: lst	^super new initialize:lst</body></methods><methods><class-id>Sol.Card</class-id> <category>accessing</category><body package="Sol-Model">deck	^deck</body><body package="Sol-Model">deck: anObject	deck := anObject</body><body package="Sol-Model">name	^name</body><body package="Sol-Model">name: anObject	name := anObject</body><body package="Sol-Model">side	^side</body><body package="Sol-Model">side: anObject	side := anObject</body><body package="Sol-Model">suit	^suit</body><body package="Sol-Model">suit: anObject	suit := anObject</body><body package="Sol-Model">value	^value</body><body package="Sol-Model">value: anObject	value := anObject</body></methods><methods><class-id>Sol.Card</class-id> <category>events</category><body package="Sol-Model">selected	self triggerEvent:#cardSelected</body><body package="Sol-Model">turnRound	"Turns the card round"	self side = #up ifTrue:[self side:#down]                            ifFalse:[self side:#up].	self changed:#cardSide</body></methods><methods><class-id>Sol.Card</class-id> <category>printing</category><body package="Sol-Model">printOn: aStream	self suit printOn: aStream.	aStream nextPutAll: ': '.	self name printOn: aStream.	aStream nextPut: $(.	self value printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Sol.Card</class-id> <category>test</category><body package="Sol-Model">= aCard	[self name = aCard value] and:[self name = aCard suit]</body></methods><methods><class-id>Sol.Card</class-id> <category>initialization</category><body package="Sol-Model">initializeName: aString value: aNumber suit: aSuit deck: aDeck side: cardSide	name := aString.	value := aNumber.	suit := aSuit.	side := cardSide.	deck := aDeck</body></methods><methods><class-id>Sol.Card class</class-id> <category>instance creation</category><body package="Sol-Model">name: aString value: aNumber suit: aSuit deck: aDeck 	^ super new initializeName: aString value: aNumber suit: aSuit deck: aDeck side: 0</body><body package="Sol-Model">name: aString value: aNumber suit: aSuit deck: aDeck side: cardSide	^ super new initializeName: aString value: aNumber suit: aSuit deck: aDeck side: #down</body></methods><methods><class-id>Sol.Golf</class-id> <category>initializing</category><body package="Sol-Golf">initializePlayingPiles	|c pile |	c := OrderedCollection new.	self playingPilesAmount timesRepeat:[ 		pile := self playingPilesClass new.		self distributor give: 6 to: pile.		c add: pile ].	^c</body><body package="Sol-Golf">initializeTalon	|c|	c := self deck takeAll.	^Talon withCards: c take: 1 cardsManager: self</body><body package="Sol-Golf">playingPilesAmount	^6</body><body package="Sol-Golf">playingPilesClass	^GolfPile</body><body package="Sol-Golf">playingPilesLayoutClass	^VerticalPileLayout</body><body package="Sol-Golf">repositoryLayoutClass	^FlatPileLayout</body><body package="Sol-Golf">takeTalonCards	|card| 	card := self talon takeCards: 1.	self repository addCards: card</body></methods><methods><class-id>Sol.Golf</class-id> <category>playing</category><body package="Sol-Golf">takeCardsFromTalon: aTalon	aTalon isEmpty not ifTrue: [self repository addCard: aTalon takeLastCard]</body></methods><methods><class-id>Sol.AST.MoveHeader</class-id> <category>initialization</category><body package="Sol-AST">initialize: pila1 target:pila2	source:=pila1.	target:= pila2.</body></methods><methods><class-id>Sol.AST.MoveHeader</class-id> <category>getters</category><body package="Sol-AST">source	^source</body><body package="Sol-AST">target	^target</body></methods><methods><class-id>Sol.AST.MoveHeader</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'mover '.	source printOn: aStream.	aStream nextPutAll: ' =&gt; '.	target printOn: aStream.</body></methods><methods><class-id>Sol.AST.MoveHeader class</class-id> <category>creation</category><body package="Sol-AST">new: pila1 target:pila2	^super new initialize: pila1 target:pila2</body></methods><methods><class-id>Sol.AST.WastePiles</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:' pilas auxiliares'.</body></methods><methods><class-id>Sol.PileLayout</class-id> <category>coordinates</category><body package="Sol-UI">nextX: x sep: sep	^self subclassResponsibility</body><body package="Sol-UI">nextY: x sep: sep	^self subclassResponsibility</body></methods><methods><class-id>Sol.HorizontalPileLayout</class-id> <category>coordinates</category><body package="Sol-UI">nextX: x sep: sep	^x + sep</body><body package="Sol-UI">nextY: y sep: sep	^y</body></methods><methods><class-id>Sol.FlatPileLayout</class-id> <category>coordinates</category><body package="Sol-UI">nextX: x sep: sep	^x</body><body package="Sol-UI">nextY: y sep: sep	^y</body></methods><methods><class-id>Sol.VerticalPileLayout</class-id> <category>coordinates</category><body package="Sol-UI">nextX: x sep: sep	^x</body><body package="Sol-UI">nextY: y sep: sep	^y + sep</body></methods><methods><class-id>Sol.GolfRepository</class-id> <category>accessing</category><body package="Sol-Golf">canAddCards: c	| card last|	self isEmpty ifTrue:[^false].	card := c first.	last := self cards last.	^last value = ((card value + 1) \\ self cardsPerSuit) or: 	[last value = ((card value - 1) \\ self cardsPerSuit)]</body><body package="Sol-Golf">canTakeFrom: c	^false</body></methods><methods><class-id>Sol.XMLConfigReader</class-id> <category>initializing</category><body package="Sol-Config">initialize: aFilename	filename := aFilename.	builder := ConfigBuilder new.</body></methods><methods><class-id>Sol.XMLConfigReader</class-id> <category>reading</category><body package="Sol-Config">createConfigFrom: rootElement	"Crea una configuracion desde un elemento XML recursivamente"	|trueElements mapping |	"Si tiene atributos pasarlos abajo y evaluar de nuevo con el elemento modificado (TODO: por ahora no se soportan atributos)"	"Si es una hoja, obtener el texto y salir"	(self isDataElement: rootElement ) ifTrue: [^builder buildString: (self elementData: rootElement)].	trueElements := self getElements: rootElement.	"Puede estar enumerando elementos"	(self isListOfElements:rootElement) ifTrue: [ 		"Crear la coleccion de elementos"		^builder buildList: (trueElements collect: [:e | self createConfigFrom: e])].		"Es un elemento complejo cuyos elementos no son una lista, crear un mapping"	"Otra posibilidad es ir dando los datos al builder iterativamente"	mapping := Dictionary new.	trueElements do:[:e | 		mapping at: e tag type put: (self createConfigFrom: e)].	^builder buildMapping: mapping.</body><body package="Sol-Config">elementData: element	|text|	text := element elements first text.	"Replace blanks for cr"	text := text collect: [:char | char = Character cr ifTrue: [$ ] ifFalse: [char]].	"trim the blanks"	^text trimBlanks</body><body package="Sol-Config">getElements: element	^element elements select: [:e | e isElement].</body><body package="Sol-Config">isDataElement: element	^(self getElements: element) isEmpty</body><body package="Sol-Config">isListOfElements: element	|tag elements|	elements := self getElements: element.	(elements size &lt; 2) ifTrue:[^false].	tag := elements first tag type.	elements do: [:e | (e tag type = tag) ifFalse: [^false]].	^true</body><body package="Sol-Config">read	|parser|	parser := XML.XMLParser new.	parser validate: false.	parser parse: filename.	^self createConfigFrom: parser document root</body></methods><methods><class-id>Sol.XMLConfigReader class</class-id> <category>instance creation</category><body package="Sol-Config">on: aFilename	^super new initialize: aFilename</body></methods><methods><class-id>Sol.AST.Rules</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'Reglas ='.	aStream cr.	rules do:[:r| aStream nextPutAll:'* '. r printOn:aStream. aStream nextPutAll:'.'. aStream cr.].</body></methods><methods><class-id>Sol.AST.Rules</class-id> <category>initialization</category><body package="Sol-AST">initialize:lst	rules:=lst</body></methods><methods><class-id>Sol.AST.Rules</class-id> <category>getters</category><body package="Sol-AST">rules	^rules</body></methods><methods><class-id>Sol.AST.Rules class</class-id> <category>creation</category><body package="Sol-AST">new:lst	^super new initialize: lst</body></methods><methods><class-id>Sol.AST.Or</class-id> <category>printing</category><body package="Sol-AST">printOperation:aStream	aStream nextPutAll: ' || '</body></methods><methods><class-id>Sol.GolfPile</class-id> <category>accessing</category><body package="Sol-Golf">canAddCards: c	^false</body><body package="Sol-Golf">canTakeFrom: aCard	^self cards last = aCard</body></methods><methods><class-id>Sol.AST.CardType</class-id> <category>getters</category><body package="Sol-AST">card	^card</body></methods><methods><class-id>Sol.AST.CardType</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' tipo('.	card printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.CardType</class-id> <category>initialization</category><body package="Sol-AST">initialize: c	card:=c.</body></methods><methods><class-id>Sol.AST.CardType class</class-id> <category>creation</category><body package="Sol-AST">new: card	^super new initialize:card</body></methods><methods><class-id>Sol.AST.Joker</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' joker'.</body></methods><methods><class-id>Sol.AST.Queen</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' reina'.</body></methods><methods><class-id>Sol.AST.As</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' as'.</body></methods><methods><class-id>Sol.AST.King</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' rey'.</body></methods><methods><class-id>Sol.AST.Ten</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' 10'.</body></methods><methods><class-id>Sol.AST.Number</class-id> <category>getters</category><body package="Sol-AST">number	^number</body></methods><methods><class-id>Sol.AST.Number</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: number asString</body></methods><methods><class-id>Sol.AST.Number</class-id> <category>initialization</category><body package="Sol-AST">initialize:n	number:=n</body></methods><methods><class-id>Sol.AST.Number class</class-id> <category>creation</category><body package="Sol-AST">new:number	^super new initialize:number</body></methods><methods><class-id>Sol.AST.PlayingPilesSpec</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'pilas de juegos :'.	aStream nextPutAll: count asString.</body></methods><methods><class-id>Sol.AST.PlayingPilesSpec</class-id> <category>initialization</category><body package="Sol-AST">initialize:cant	count:=cant</body></methods><methods><class-id>Sol.AST.PlayingPilesSpec</class-id> <category>getters</category><body package="Sol-AST">count	^count</body></methods><methods><class-id>Sol.AST.PlayingPilesSpec class</class-id> <category>creation</category><body package="Sol-AST">new: cant	^super new initialize:cant</body></methods><methods><class-id>Sol.DeckClassesConfigProxy</class-id> <category>accessing</category><body package="Sol-Config">deckClasses	^config collect:[:class | DeckClassConfigProxy name: (class at: 'name') suits: (class at: 'suits') cardsPerSuit: (class at: 'cards_per_suit')]</body><body package="Sol-Config">deckClassNamed: aString	self deckClasses do: [:class | class name = aString ifTrue: [^class]].	self error: ('Error buscando la clase ', aString, '.  No esta definida tal clase.')</body></methods><methods><class-id>Sol.AST.SpanishDeck</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' español'.</body></methods><methods><class-id>Sol.AST.Club</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll:' trébol'</body></methods><methods><class-id>Sol.AST.ComparisonExpression</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	elem1 printOn: aStream.	self print: aStream.	elem2 printOn: aStream.</body></methods><methods><class-id>Sol.AST.ComparisonExpression</class-id> <category>getters</category><body package="Sol-AST">element1	^elem1</body><body package="Sol-AST">element2	^elem2</body></methods><methods><class-id>Sol.AST.ComparisonExpression</class-id> <category>initialization</category><body package="Sol-AST">initialize:e1 and:e2	elem1:=e1.	elem2:=e2.</body></methods><methods><class-id>Sol.AST.ComparisonExpression class</class-id> <category>creation</category><body package="Sol-AST">new:e1 and:e2	^super new initialize:e1 and:e2</body></methods><methods><class-id>Sol.AST.Comparison</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:' =='.</body></methods><methods><class-id>Sol.AST.ComparisonNot</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:' /='.</body></methods><methods><class-id>Sol.AST.GreaterE</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:'&gt;='.</body></methods><methods><class-id>Sol.AST.Lower</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:'&lt;'.</body></methods><methods><class-id>Sol.AST.LowerE</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:'&lt;='.</body></methods><methods><class-id>Sol.AST.Greater</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:'&gt;'.</body></methods><methods><class-id>Sol.AST.Implies</class-id> <category>printing</category><body package="Sol-AST">printOperation:aStream	aStream nextPutAll: ' =&gt; '</body></methods><methods><class-id>Sol.AST.FoundationSpec</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll:'bases :'.	aStream nextPutAll: count asString.</body></methods><methods><class-id>Sol.AST.FoundationSpec</class-id> <category>initialization</category><body package="Sol-AST">initialize:cant	count:=cant</body></methods><methods><class-id>Sol.AST.FoundationSpec</class-id> <category>getters</category><body package="Sol-AST">count	^count</body></methods><methods><class-id>Sol.AST.FoundationSpec class</class-id> <category>creation</category><body package="Sol-AST">new: cant	^super new initialize:cant</body></methods><methods><class-id>Sol.AST.InitCount</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	self print:aStream.	aStream nextPutAll:' :'.	count printOn: aStream.</body></methods><methods><class-id>Sol.AST.InitCount</class-id> <category>initialization</category><body package="Sol-AST">initialize:cant	count:=cant</body></methods><methods><class-id>Sol.AST.InitCount</class-id> <category>getters</category><body package="Sol-AST">count	^count</body></methods><methods><class-id>Sol.AST.InitCount class</class-id> <category>creation</category><body package="Sol-AST">new: cant	^super new initialize:cant</body></methods><methods><class-id>Sol.AST.TalonsInitCount</class-id> <category>printing</category><body package="Sol-AST">print:aStream	aStream nextPutAll:' cartas en pozos '.</body></methods><methods><class-id>Sol.AST.WastePileInitCount</class-id> <category>printing</category><body package="Sol-AST">print:aStream	aStream nextPutAll:' cartas en pilas auxiliares'.</body></methods><methods><class-id>Sol.AST.PlayingPileInitCount</class-id> <category>printing</category><body package="Sol-AST">print:aStream	aStream nextPutAll:' cartas en pilas de juego	'.</body></methods><methods><class-id>Sol.AST.FoundationsInitCount</class-id> <category>printing</category><body package="Sol-AST">print:aStream	aStream nextPutAll:' cartas en bases '.</body></methods><methods><class-id>Sol.AST.Spade</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' pica'.</body></methods><methods><class-id>Sol.AST.Diamond</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' diamante'.</body></methods><methods><class-id>Sol.AST.CardColorExpression</class-id> <category>getters</category><body package="Sol-AST">card	^card</body></methods><methods><class-id>Sol.AST.CardColorExpression</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' color('.	card printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.CardColorExpression</class-id> <category>initialization</category><body package="Sol-AST">initialize: c	card:=c.</body></methods><methods><class-id>Sol.AST.CardColorExpression class</class-id> <category>creation</category><body package="Sol-AST">new: card	^super new initialize: card</body></methods><methods><class-id>Sol.AST.Black</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' negro'.</body></methods><methods><class-id>Sol.AST.Red</class-id> <category>printing</category><body package="Sol-AST">printOn:aStream	aStream nextPutAll: ' rojo'.</body></methods><methods><class-id>Sol.AST.PreviousCard</class-id> <category>getters</category><body package="Sol-AST">card	^card</body></methods><methods><class-id>Sol.AST.PreviousCard</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: ' anterior('.	card printOn:aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.PreviousCard</class-id> <category>initialization</category><body package="Sol-AST">initialize: c	card:=c.</body></methods><methods><class-id>Sol.AST.PreviousCard class</class-id> <category>creation</category><body package="Sol-AST">new: card	^super new initialize: card</body></methods><methods><class-id>Sol.AST.NextCard</class-id> <category>getters</category><body package="Sol-AST">card	^card</body></methods><methods><class-id>Sol.AST.NextCard</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'siguiente('.	card printOn:aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.NextCard</class-id> <category>initialization</category><body package="Sol-AST">initialize: c	card:= c.</body></methods><methods><class-id>Sol.AST.NextCard class</class-id> <category>creation</category><body package="Sol-AST">new:card	^super new initialize: card</body></methods><methods><class-id>Sol.AST.TopPile</class-id> <category>printing</category><body package="Sol-AST">printOn: aStream	aStream nextPutAll: 'tope('.	pile printOn:aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Sol.AST.TopPile</class-id> <category>initialization</category><body package="Sol-AST">initialize:p	pile:=p</body></methods><methods><class-id>Sol.AST.TopPile</class-id> <category>getters</category><body package="Sol-AST">pile	^pile</body></methods><methods><class-id>Sol.AST.TopPile class</class-id> <category>creation</category><body package="Sol-AST">new: pile	^super new initialize:pile</body></methods><methods><class-id>Sol.StandardPockerDeckVisualStyle class</class-id> <category>cards image files</category><body package="Sol-UI">path	^'./cards/cardset-standard'</body></methods><methods><class-id>Sol.AST.Plus</class-id> <category>printing</category><body package="Sol-AST">print: aStream	aStream nextPutAll:'+'.</body></methods><methods><class-id>Sol.Deck</class-id> <category>initialization</category><body package="Sol-Model">initialize	"Esto no se hace más. Hay un nuevo patron (que reemplaza al viejo TemplateMethod en algunos casos). La idea es configurar la nueva instancia de una clase desde afuera (por ejemplo desde un archivo de configuracion)"	"Existe la posibilidad deseable de convertir el archivo de configuracion en un DSL con chequeos e informe de errores, especialmente para ser configurado por personas que no son programadores"	self halt.	cards := self initializeCards.</body><body package="Sol-Model">initialize: deckType suits: _suits cardsPerSuit: aNumber cards: _cards	type := deckType.	suits := _suits.	cardsPerSuit := aNumber.	cards := _cards.</body></methods><methods><class-id>Sol.Deck</class-id> <category>accessing</category><body package="Sol-Model">cardsPerSuit	^cardsPerSuit</body><body package="Sol-Model">cardsPerSuit: anObject	cardsPerSuit := anObject</body><body package="Sol-Model">mix	|r i1 i2 c|	r := Random new.	self mixTimes timesRepeat: [		i1 := (r next * self cards size) truncated + 1.		i2 := (r next * self cards size) truncated + 1.		c := self cards at: i1.		self cards at: i1 put: (self cards at: i2).		self cards at: i2 put: c]</body><body package="Sol-Model">mixTimes	^mixTimes</body><body package="Sol-Model">mixTimes: anObject	mixTimes := anObject</body><body package="Sol-Model">suits	^suits</body><body package="Sol-Model">suits: anObject	suits := anObject</body><body package="Sol-Model">type	^type</body><body package="Sol-Model">type: anObject	type := anObject</body></methods><methods><class-id>Sol.Deck class</class-id> <category>instance creation</category><body package="Sol-Model">type: deckType suits: suits cardsPerSuit: aNumber 	"Las cartas deben crearse desde afuera ya que la asignacion de valores a las cartas depende de la aplicacion, no del mazo"	^super new initialize: deckType suits: suits cardsPerSuit: aNumber cards: OrderedCollection new</body><body package="Sol-Model">type: deckType suits: suits cardsPerSuit: aNumber cards: cards	"Las cartas deben crearse desde afuera ya que la asignacion de valores a las cartas depende de la aplicacion, no del mazo"	^super new initialize: deckType suits: suits cardsPerSuit: aNumber cards: cards</body></methods><methods><class-id>UI.ApplicationWindow</class-id> <category>sol</category><body package="Sol-UI">findPileInterestedInDrop: aPile at: aPoint	"Esto se llama alto hackaso feo, pero es necesario"	"Para la parte grafica: propaga el evento de que una carta fue soltada para que alguien lo maneje"	self downcastLocalEvent: #cardsDrop with: aPile -&gt; [:x | ^x] at: aPoint from: self.	^nil</body></methods><methods><class-id>Sol.SolApplication class</class-id> <category>resources</category><body package="Sol-Model">menuSpec	"Tools.MenuEditor new openOnClass: self andSelector: #menuSpec"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Archivo' 				#nameKey: #menuFile 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Salir' 							#nameKey: #menuQuit ) ) #(1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Sol.SolApplication class</class-id> <category>interface specs</category><body package="Sol-Model">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: 'Solitario' 			#bounds: #(#{Graphics.Rectangle} 512 384 775 604 ) 			#flags: 4 			#menu: #menuSpec ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #canvas 					#flags: 0 					#component: #canvas ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationWindow</name><environment>UI</environment><super>UI.ScheduledWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor application sendWindowEvents receiveWindowEvents windowEventBlock damageRepairIsLazy activationNotification isEventDriven toolbarVisible dropTarget dragDropInProgress dragDropTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view sensor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SelectionTracker</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>CompositeView</name><environment>UI</environment><super>Graphics.DependentComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class></st-source>